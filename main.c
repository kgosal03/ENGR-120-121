/*
AUTHOR: Alex, Karanbir Gosal, Tanvir Kahlon, Tavin
Course: ENGR 121
Project: Autonomous robot
Date: March 28, 2023
*/
#pragma config(Sensor, in1,    irSensor,       sensorReflection)
#pragma config(Sensor, dgtl1,  led1,           sensorDigitalOut)
#pragma config(Sensor, dgtl6,  led3,           sensorDigitalOut)
#pragma config(Sensor, dgtl8,  ultrasonic,     sensorSONAR_cm)
#pragma config(Sensor, dgtl11, button1,        sensorTouch)
#pragma config(Motor,  port2,           leftMotor,     tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           rightMotor,    tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           armMotor,      tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//State when the robot is in motion
typedef enum TRAVEL_STATE_OF_ROBOT {
    //When the robot is far
	ITS_FAR_AWAY = 0,
	//when the robot is at the right distance
	APPROPRIATE_DISTANCE,
	//When the robot is too close
	VERY_CLOSE,
	//Initial state during start
  START_CHECK
};

//State whether the robot detected the beacon or not
typedef enum STATE_OF_BEACON_DETECTION {
    //When it had not detected the target yet
	UNDETECTED = 0,
	//When the beacon is detected
	DETECTED
};

//Setting variable for IR threshold
const int threshold_IR_Emitter = 60;

//Setting variable for the distance threshold
const int distance_threshold = 25;

//Setting variable for the motor speed
const int motor_speed = 32;

//defining the initial state for both beacon detection and travel state
static STATE_OF_BEACON_DETECTION detection_state = UNDETECTED;
//Travel state of the the robot when at rest
static TRAVEL_STATE_OF_ROBOT travel_state = START_CHECK;

//Setting variables for flags
//Variable for the button if pushed or not to start the robot
bool button1_pushed = false;
//Check once all the tasks are completed
bool check_final = false;
//Variable to check if the object or beacon is found or not
bool object_found = false;
//Variable to check if the robot reached the object and ready to drop the object
bool reached_object = false;

//Function to make the robot go in forward direction
void moveForward()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      {
  motor[leftMotor] = 29;
  motor[rightMotor] = 29;
}

//Function to make the robot go in backward direction
void moveBackward() {
  motor[leftMotor] = -motor_speed;
  motor[rightMotor] = -motor_speed;
}


//Function to make the robot go in right direction
void turnRight() {
  motor[leftMotor] = motor_speed;
  motor[rightMotor] = -motor_speed;
}

//Function to make the robot stop moving
void stopMoving() {
  motor[leftMotor] = 0;
  motor[rightMotor] = 0;
}

//Function the object dropping mechanism
void runArmMotor() {
	motor[armMotor] = -35;
}

//Function to check the light detected by the IR sensor
int monitorLight()
{
    //Initializing the min_value for the IR sensor
    static int min_value = 4096;
    //Initializing the max_value for the IR sensor
    static int max_value = 0;
    //Initializing the difference in the IR sensor
    static int diff_IRVal = 0;
    //Variable to store the current value of the IR sensor
    int lightLevel1 = SensorValue[irSensor];

    //Setting up the timer to keep track of the target
    if ( time1[T1] > 100 )  {
        //Computing the difference
        diff_IRVal = max_value - min_value;
        max_value = 0;
        min_value = 4096;
        clearTimer(T1);
    }
    else {
        //Check if the Current IR sensor value is less than the min-value
		if ( lightLevel1 < min_value ) {
			min_value = lightLevel1;
			//Check if the Current IR sensor value is greater than the max-value
			} else if ( lightLevel1 > max_value ) {
			max_value = lightLevel1;
		}
	}
	//returning the difference value of the min-max
    return( diff_IRVal );
}

//Function to find the target or beacon in this case with the help of monitor_light function
void find_target_object() {
  //Storing the beacon level which was computed in the monitorLight() to compare with the threshold
  int beacon_level = monitorLight();

  //Switch cases for the detection state of the robot IR sensor
  switch( detection_state ) {

  //Case when the beacon is not yet detected
  case UNDETECTED:
    //Keep turning right
    turnRight();
    //If the difference is greater than the threshold we got the beacon otherwise not
    if ( beacon_level > threshold_IR_Emitter ) {
      //Setting up the state if detected
      detection_state = DETECTED;
      }
    else {
      //Setting up the state if not detected
      detection_state = UNDETECTED;
    }
    break;

    //Case when the beacon is detected
  case DETECTED:
    //Stopping the robot in the direction of the target if the beacon is detected
    stopMoving();
    //Setting the object found as true as we got the direction for the beacon
    if ( beacon_level > threshold_IR_Emitter ) {
      //Detection state is detected
      detection_state = DETECTED;
      //Setting the object found as true
      object_found = true;

      } else {
      //Otherwise undetected if threshold do not meet the condition
      detection_state = UNDETECTED;
    }
    break;
  default:
    //Keeping the default state as undetected so keep spinning until the target is detected
    detection_state = UNDETECTED;
  }
}

//Function to move towards the target once the beacon is detected
void move_towards_target() {
  // Getting the current sonar value and storing in the variable
  int sonar_value = SensorValue[ultrasonic];

  //Switch cases to monitor the various travel states
  switch( travel_state ) {
  	//Initial case
    case START_CHECK:
          // If the sonar value is greater than threshold then we are too far
		  if ( sonar_value > distance_threshold + 6 ) {
		    travel_state = ITS_FAR_AWAY;
		  }
		  // If the sonar value is too less than the threshold then we are too close
		  else if(sonar_value < distance_threshold - 6) {
		    travel_state = VERY_CLOSE;
		  }
		  //Checking if our robot is in the appropriate distance for drop off to the beacon
		  else if(sonar_value > (distance_threshold - 5) && sonar_value < (distance_threshold + 5))
		    travel_state = APPROPRIATE_DISTANCE;
		      break;

	//Case when the robot is still far from the beacon
    case ITS_FAR_AWAY:
      //Keep the robot moving forward until the we are far from the beacon
      moveForward();
           // If the sonar value is greater than threshold then we are too far
		  if ( sonar_value > distance_threshold + 6 ) {
		    travel_state = ITS_FAR_AWAY;
		  }
		  // If the sonar value is too less than the threshold then we are too close
		  else if(sonar_value < distance_threshold - 6) {
		    travel_state = VERY_CLOSE;
		  }
		  //Checking if our robot is in the appropriate distance for drop off to the beacon
		  else if(sonar_value > (distance_threshold - 5) && sonar_value < (distance_threshold + 5))
		    travel_state = APPROPRIATE_DISTANCE;

      break;

    //Case when the robot is at the appropriate distance from the beacon
    case APPROPRIATE_DISTANCE:
      stopMoving();
           // If the sonar value is greater than threshold then we are too far
		  if ( sonar_value > distance_threshold + 6 ) {
		    travel_state = ITS_FAR_AWAY;
		  }
		  // If the sonar value is too less than the threshold then we are too close
		  else if(sonar_value < distance_threshold - 6) {
		    travel_state = VERY_CLOSE;
		  }
		  //Checking if our robot is in the appropriate distance for drop off to the beacon
		  else if(sonar_value > (distance_threshold - 5) && sonar_value < (distance_threshold + 5))
		    travel_state = APPROPRIATE_DISTANCE;
		      reached_object = true;

      break;
    //When the robot it too close to the beacon and not at the right spot
    case VERY_CLOSE:
      moveBackward();
           // If the sonar value is greater than threshold then we are too far
		  if ( sonar_value > distance_threshold + 6 ) {
		    travel_state = ITS_FAR_AWAY;
		  }
		  // If the sonar value is too less than the threshold then we are too close
		  else if(sonar_value < distance_threshold - 6) {
		    travel_state = VERY_CLOSE;
		  }
		  //Checking if our robot is in the appropriate distance for drop off to the beacon
		  else if(sonar_value > (distance_threshold - 5) && sonar_value < (distance_threshold + 5))
		    travel_state = APPROPRIATE_DISTANCE;

      break;

    default:
      //Setting the default state to start check to keep it in Finite State
      travel_state = START_CHECK;
  }
}

//Function to check if the button is pushed or not
void monitor_button_input()
{
  //Checking if the button is pushed and our bool is true
  if(SensorValue(button1) && !button1_pushed)
  {
    //Setting the button pushed
    button1_pushed = true;
  }
}

task main()
{

  //Making sure the led is OFF at the start
  SensorValue[led1] = 0;

  // Running the loop to detect beacon and move to the target
  while(!check_final) {
    //Monitoring if the button is pushed
    monitor_button_input();
    // if statement to enter if button is pushed
	if(button1_pushed == true) {
		//Making sure the travel and beacon detection state are configured
		detection_state = UNDETECTED;
		travel_state = START_CHECK;

		// Loop to go on until the robot finds the beacon
		while(!object_found) {
            find_target_object();
        }

        //Once the object is found
        if(object_found){
            // LED turns on once the beacon is detected
            SensorValue[led1]	=1;
            //Waits for 2 sec
            wait1Msec(2000);
            // LED turns off after giving the signal that it detected the beacon
            SensorValue[led1]=0;
        }
        //Waits for 2 sec once it detects the beacon and gave signal
		wait1Msec(2000);

		// Loop to make the robot move towards the beacon
        while(!reached_object) {
            //Calling the function to help the robot reach the beacon staying in a finite state
            move_towards_target();
        }

        //Turning the final LED on once it reached the beacon and is at the APPROPRIATE Distance
        SensorValue[led1] = 1;
        //Waits for another 2 sec so that it can settle down the movement and the observation for TA is clear
        wait1Msec(2000);

        //Drop the ball on the target by running the arm motor and dropping the ball on the beacon
        runArmMotor();
        //Arm motor runs for 5 sec making sure the ball is perfectly dropped on the beacon
        wait1Msec(5000);
        //Stopping the arm motor once its task is done
        motor[armMotor]=0;


        //Signal that the object has been dropped
        SensorValue[led1] = 0;
        //Move Backward once the object has been placed
        moveBackward();
        //Moves backward for 1 sec
        wait1Msec(1000);

        //Go back to resting state
        stopMoving();
        //Signaling that the task has been successfully completed by turning on the LED for the final time
        SensorValue[led1] = 1;
	}
	    //Otherwise button pushed is false and the robot stays at rest
    button1_pushed = false;
  }
}
